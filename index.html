<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éú„Éº„É´„ÇíÈÅø„Åë„Çã„Å†„Åë„ÅÆ„Ç≤„Éº„É† (ËªΩÈáèÂåñ„ÉªÊúÄÈÅ©ÂåñÁâà)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        /* --- ÂÖ®‰Ωì„ÅÆË®≠ÂÆö --- */
        body { margin: 0; overflow: hidden; font-family: 'M PLUS Rounded 1c', sans-serif; user-select: none; background-color: #ffecf2; }
        .bg-balls-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; z-index: -1; pointer-events: none; }
        .bg-ball { position: absolute; border-radius: 50%; opacity: 0.6; animation: floatBall linear infinite; }
        @keyframes floatBall { 0% { transform: translateY(110vh) rotate(0deg); } 100% { transform: translateY(-10vh) rotate(360deg); } }
        .bb1 { width: 80px; height: 80px; background: #ffadd6; left: 10%; animation-duration: 8s; animation-delay: 0s; }
        .bb2 { width: 120px; height: 120px; background: #aaddff; left: 30%; animation-duration: 12s; animation-delay: 2s; }
        .bb3 { width: 60px; height: 60px; background: #ffffaa; left: 50%; animation-duration: 10s; animation-delay: 1s; }
        .bb4 { width: 100px; height: 100px; background: #aaffaa; left: 70%; animation-duration: 14s; animation-delay: 3s; }
        .bb5 { width: 70px; height: 70px; background: #ddaaff; left: 90%; animation-duration: 9s; animation-delay: 0.5s; }

        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #top-bar { 
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center;
            padding: 10px 30px; background: rgba(255, 255, 255, 0.8); border-radius: 30px; border: 3px solid #ffadd6;
            box-shadow: 0 5px 15px rgba(255, 173, 214, 0.4);
        }
        #timer-label { font-size: 16px; color: #ff88bb; font-weight: bold; letter-spacing: 2px; margin-bottom: -5px; }
        #timer { font-size: 56px; font-weight: 900; color: #555; text-shadow: 2px 2px 0 #fff, 4px 4px 0 #ffadd6; line-height: 1; }
        
        .status-line { display: flex; justify-content: center; gap: 20px; margin-top: 5px; }
        .status-text { font-size: 16px; font-weight: bold; color: #fff; padding: 5px 15px; border-radius: 20px; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        #speed-display { background: #ffcc00; }
        #shield-display { background: #ff6699; display: none; }
        
        /* „Çπ„Ç≠„É´„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
        .skill-container { display: flex; gap: 10px; margin-top: 8px; }
        .skill-box {
            background: #aaa; padding: 5px 15px; border-radius: 20px; color: #fff; font-weight: bold; font-size: 14px;
            transition: all 0.3s; display: flex; align-items: center; justify-content: center; min-width: 100px;
        }
        .skill-box.ready { background: #00ccff; box-shadow: 0 0 10px #00ccff; transform: scale(1.05); }
        .skill-box.active { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
        .skill-box.cooldown { background: #555; color: #999; }

        .overlay-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, rgba(255, 220, 240, 0.95) 0%, rgba(220, 240, 255, 0.95) 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; display: none; 
        }
        #start-screen { display: flex; z-index: 150; }

        h1 { font-size: 72px; color: #ff6699; margin: 0 0 20px 0; text-shadow: 3px 3px 0 #fff, 5px 5px 0 #66ccff, 7px 7px 0 #ffcc00; text-align: center; line-height: 1.2; font-weight: 900; }
        
        .info-wrapper { display: flex; gap: 20px; margin-bottom: 20px; }
        .info-box {
            background: #fff; border: 4px dotted #66ccff; border-radius: 25px; padding: 20px; text-align: left; width: 320px;
            box-shadow: 0 10px 20px rgba(100, 200, 255, 0.2); color: #555;
        }
        .box-title { color: #ff6699; font-weight: 900; margin-bottom: 10px; font-size: 20px; text-align: center; border-bottom: 2px dashed #ffecf2; padding-bottom: 5px; }
        .control-row { font-size: 16px; color: #666; margin: 8px 0; display: flex; align-items: center; font-weight: bold; }
        .key {
            display: inline-block; background: #ffeedd; border: 2px solid #ffbb99; border-bottom: 4px solid #ffbb99;
            border-radius: 12px; padding: 4px 10px; font-weight: bold; color: #ff8866; margin-right: 10px; min-width: 30px; text-align: center; font-size: 14px;
        }
        .item-icon {
            display: inline-block; width: 28px; height: 28px; margin-right: 10px; border-radius: 50%;
            text-align: center; line-height: 28px; font-size: 18px; background: #fff; border: 2px solid #eee; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .icon-speed { color: #ffcc00; border-color: #ffeeaa; }
        .icon-heart { color: #ff6699; border-color: #ffaabb; }
        .icon-skill { color: #00ccff; border-color: #ccffff; font-size: 16px; }

        .btn-container { display: flex; gap: 20px; align-items: center; margin-bottom: 15px; margin-top: 5px; }
        button.kawaii-btn {
            border: none; padding: 15px 40px; font-size: 22px; font-weight: 900; cursor: pointer; transition: all 0.2s;
            font-family: 'M PLUS Rounded 1c', sans-serif; min-width: 220px; border-radius: 50px; color: #fff;
            box-shadow: 0 6px 0 rgba(0,0,0,0.1), 0 15px 20px rgba(0,0,0,0.1); position: relative; top: 0;
        }
        button.kawaii-btn:hover { transform: translateY(-3px); box-shadow: 0 8px 0 rgba(0,0,0,0.1), 0 20px 30px rgba(0,0,0,0.15); }
        button.kawaii-btn:active { transform: translateY(4px); box-shadow: 0 2px 0 rgba(0,0,0,0.1), 0 5px 10px rgba(0,0,0,0.1); }
        #start-btn, #retry-btn { background: linear-gradient(to bottom, #ff88bb, #ff6699); text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        #start-btn:hover, #retry-btn:hover { background: linear-gradient(to bottom, #ff99cc, #ff77aa); }
        button.kawaii-btn.secondary { min-width: 160px; font-size: 18px; padding: 12px 30px; background: linear-gradient(to bottom, #66ccff, #44aaff); }
        button.kawaii-btn.secondary:hover { background: linear-gradient(to bottom, #88ddff, #66bbff); }
        #mute-btn { margin-left: 20px; padding: 10px 25px; font-size: 16px; min-width: auto; border-radius: 30px; }
        #mute-btn.muted { background: linear-gradient(to bottom, #aaa, #888); }

        .volume-container {
            display: flex; align-items: center; justify-content: center; width: 100%; margin-top: 10px;
            color: #6699ff; font-weight: bold; background: rgba(255,255,255,0.6); padding: 8px 20px; border-radius: 30px; width: fit-content;
        }
        .volume-label { margin-right: 15px; font-size: 16px; }
        input[type=range] { -webkit-appearance: none; width: 150px; height: 10px; background: #ddeeff; border-radius: 10px; outline: none; border: 2px solid #bfe0ff; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #ff6699; cursor: pointer; border: 3px solid #fff; box-shadow: 0 3px 5px rgba(0,0,0,0.2); }

        #result-title { font-size: 80px; color: #ff6699; margin-bottom: 10px; text-shadow: 3px 3px 0 #fff, 6px 6px 0 #ffcc00; }
        #final-score { font-size: 50px; color: #555; margin-bottom: 40px; font-weight: 900; text-shadow: 2px 2px 0 #fff; }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #ffecf2; color: #ff6699; 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 32px; font-weight: 900; letter-spacing: 2px; z-index: 200; text-shadow: 2px 2px 0 #fff;
        }
        #error-log { color: #ff5555; font-size: 14px; margin-top: 20px; white-space: pre-wrap; text-align: left; max-width: 80%; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 10px; border: 2px solid #ffaaaa; display: none; }
        #sound-notice { font-size: 12px; color: #88aaff; margin-top: 10px; font-weight: bold; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="loading">
    <div id="loading-text">LOADING...</div>
    <div id="error-log"></div>
</div>

<div class="bg-balls-container">
    <div class="bg-ball bb1"></div> <div class="bg-ball bb2"></div> <div class="bg-ball bb3"></div>
    <div class="bg-ball bb4"></div> <div class="bg-ball bb5"></div>
</div>

<div id="start-screen" class="overlay-screen">
    <h1>„Éú„Éº„É´„ÇíÈÅø„Åë„Çã„Å†„Åë„ÅÆ„Ç≤„Éº„É†</h1>
    
    <div class="info-wrapper">
        <div class="info-box">
            <div class="box-title">Êìç‰ΩúÊñπÊ≥ï & „Ç¢„Ç§„ÉÜ„É†</div>
            <div class="control-row"><span class="key">Âè≥„ÇØ„É™„ÉÉ„ÇØ</span> ÁßªÂãï / <span class="key">S</span> ÂÅúÊ≠¢</div>
            <div class="control-row"><span class="item-icon icon-speed">‚òÜ</span> „Çπ„Éî„Éº„ÉâUP (Ê∞∏Á∂ö)</div>
            <div class="control-row"><span class="item-icon icon-heart">‚ô°</span> „Éú„Éº„É´„Çí1ÂõûÈò≤„Åê</div>
        </div>

        <div class="info-box">
            <div class="box-title">„Çπ„Ç≠„É´ (ÊôÇÈñì„ÅßËß£Á¶Å)</div>
            <div class="control-row"><span class="key">Q</span> ÈõªÊíÉÁéâ (60ÁßíÂæå)</div>
            <div style="font-size:14px; margin-left: 5px;">„Éî„É≥„ÇØ„ÅÆ„Éú„Éº„É´„ÇíÁ†¥Â£äÔºÅ(CD:1Áßí)</div>
            <div class="control-row" style="margin-top:15px;"><span class="key">W</span> „Éê„É™„Ç¢ (100ÁßíÂæå)</div>
            <div style="font-size:14px; margin-left: 5px;">3ÁßíÈñìÂÆà„Çã„Ç∑„Éº„É´„ÉâÂ±ïÈñã (CD:2Áßí)</div>
        </div>
    </div>

    <div class="btn-container">
        <button id="start-btn" class="kawaii-btn">„Ç≤„Éº„É†„Çπ„Çø„Éº„ÉàÔºÅ</button>
        <button id="mute-btn" class="kawaii-btn secondary">üîä Èü≥ON</button>
    </div>
    <div class="volume-container">
        <span class="volume-label">„Åä„Çì„Çä„Çá„ÅÜ</span>
        <input type="range" id="volume-slider" min="0" max="100" value="50">
    </div>
    <div id="sound-notice">‚Äªsounds„Éï„Ç©„É´„ÉÄ„Å´Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÅåÂøÖË¶Å„Åß„Åô</div>
</div>

<div id="result-overlay" class="overlay-screen">
    <h1 id="result-title">„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h1>
    <div id="final-score">Ë®òÈå≤: 0.00Áßí</div>
    <div class="btn-container">
        <button id="retry-btn" class="kawaii-btn">„ÇÇ„ÅÜ‰∏ÄÂõûÔºÅ</button>
        <button id="menu-btn" class="kawaii-btn secondary">„É°„Éã„É•„Éº„Å∏</button>
    </div>
</div>

<div id="hud">
    <div id="top-bar">
        <div id="timer-label">„Å´„Åí„ÅüÊôÇÈñì</div>
        <div id="timer">0.00</div>
        
        <div class="skill-container">
            <div id="skill-q" class="skill-box">Q: 60ÁßíÂæå...</div>
            <div id="skill-w" class="skill-box">W: 100ÁßíÂæå...</div>
        </div>

        <div class="status-line">
            <div id="speed-display" class="status-text">„Çπ„Éî„Éº„Éâ: 100%</div>
            <div id="shield-display" class="status-text">‚ô• „Éê„É™„Ç¢Áô∫Âãï‰∏≠ ‚ô•</div>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';

    function showError(msg) {
        const el = document.getElementById('error-log'); el.style.display = 'block';
        el.innerText += "Error: " + msg + "\n"; document.getElementById('loading-text').innerText = "SYSTEM FAILURE"; console.error(msg);
    }
    window.onerror = function(msg, url, line) { showError(`${msg}\nLine: ${line}`); return false; };

    class SoundManager {
        constructor() {
            this.sounds = {}; this.currentBgmKey = null;
            this.files = {
                bgm: 'sounds/bgm.mp3', start: 'sounds/start.mp3', item: 'sounds/item.mp3',
                shield: 'sounds/shield.mp3', break: 'sounds/break.mp3', defeat: 'sounds/defeat.mp3',
                menu: 'sounds/menu.mp3', skill: 'sounds/skill.mp3'
            };
            this.isMuted = false; this.masterVolume = 0.5;
        }
        init() {
            for (const [key, path] of Object.entries(this.files)) {
                const audio = new Audio(path);
                if (key === 'menu' || key === 'bgm') { audio.baseVolume = 0.2; audio.loop = true; } else { audio.baseVolume = 0.4; }
                audio.volume = audio.baseVolume * this.masterVolume;
                this.sounds[key] = audio;
                audio.onerror = () => { console.warn(`Sound file not found: ${path}`); };
            }
        }
        setVolume(val) {
            this.masterVolume = Math.max(0, Math.min(1, val));
            for (const key in this.sounds) { this.sounds[key].volume = this.sounds[key].baseVolume * this.masterVolume; }
        }
        switchBGM(key) {
            if (this.isMuted) return;
            if (this.currentBgmKey === key && this.sounds[key] && !this.sounds[key].paused) return;
            this.stopAllBGM();
            const sound = this.sounds[key];
            if (sound) { sound.currentTime = 0; sound.volume = sound.baseVolume * this.masterVolume; sound.play().catch(e => console.log("Auto-play blocked")); this.currentBgmKey = key; }
        }
        play(key) {
            if (this.isMuted || !this.sounds[key]) return;
            const sound = this.sounds[key]; sound.volume = sound.baseVolume * this.masterVolume;
            if (key !== 'menu' && key !== 'bgm') { sound.currentTime = 0; sound.play().catch(e => {}); } else { sound.play().catch(e => {}); }
        }
        stopAllBGM() {
            if (this.sounds['menu']) { this.sounds['menu'].pause(); this.sounds['menu'].currentTime = 0; }
            if (this.sounds['bgm']) { this.sounds['bgm'].pause(); this.sounds['bgm'].currentTime = 0; }
            this.currentBgmKey = null;
        }
        toggleMute() {
            this.isMuted = !this.isMuted;
            if (this.isMuted) { this.stopAllBGM(); } else { if (gameActive) this.switchBGM('bgm'); else this.switchBGM('menu'); }
            return this.isMuted;
        }
    }
    const soundManager = new SoundManager();

    const CONFIG = {
        mapLimit: 250, mapVisualSize: 600,
        basePlayerSpeed: 24, cameraHeight: 50, cameraOffsetZ: 40, 
        ballRadius: 1.5,
        baseBallSpeedMin: 15, baseBallSpeedMax: 24,
        spawnDistance: 350,
        speedItemInterval: 3.0, speedBoostAmount: 3.0, heartItemInterval: 15.0,
        skillUnlockTimeQ: 60.0,
        skillUnlockTimeW: 100.0,
        qCooldown: 1.0, wCooldown: 2.0, wDuration: 3.0
    };

    let scene, camera, renderer, clock, raycaster, mouse;
    let player, mapGroup, moveIndicator;
    let skills = [];
    let items = [];
    let lightnings = [];
    let gameActive = false;
    let survivalTime = 0;
    let spawnCooldown = 0;
    let speedItemCooldown = 0;
    let heartItemCooldown = 0;
    let currentPlayerSpeed = CONFIG.basePlayerSpeed;
    
    // „Ç∑„Éº„É´„ÉâÁÆ°ÁêÜ
    let itemShieldActive = false;
    let wSkillShieldActive = false;
    let wSkillTimer = 0;
    
    // „Çπ„Ç≠„É´ÁÆ°ÁêÜ
    let qUnlocked = false, wUnlocked = false;
    let qCoolTimer = 0, wCoolTimer = 0;
    
    let targetPos = new THREE.Vector3();

    function disposeObject(obj) {
        if (!obj) return;
        scene.remove(obj);
        obj.traverse((child) => {
            if (child.isMesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose()); else child.material.dispose();
                }
            }
        });
    }

    const Assets = { geometries: {}, materials: {} };

    function initAssets() {
        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32,32,5,32,32,32);
        grad.addColorStop(0, '#ffadd6'); grad.addColorStop(1, '#ff55a3'); 
        ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(canvas);
        Assets.geometries.ball = new THREE.SphereGeometry(1, 24, 24);
        Assets.materials.ball = new THREE.MeshStandardMaterial({ map: tex, emissive: 0xff55a3, emissiveIntensity: 0.3, roughness: 0.4 });
        
        // ÈªíÁéâ
        Assets.materials.blackBall = new THREE.MeshStandardMaterial({ 
            color: 0x111111, emissive: 0x000000, roughness: 0.1, metalness: 0.9 
        });

        const starShape = new THREE.Shape();
        const pts=5, outer=0.5, inner=0.2;
        for(let i=0; i<pts*2; i++){
            const l = i%2==0 ? outer : inner; const a = i / pts * Math.PI - Math.PI/2;
            const x = Math.cos(a)*l; const y = Math.sin(a)*l;
            if(i==0) starShape.moveTo(x,y); else starShape.lineTo(x,y);
        }
        starShape.closePath();
        Assets.geometries.star = new THREE.ExtrudeGeometry(starShape, { depth: 0.1, bevelEnabled: true, bevelThickness:0.02, bevelSize:0.02 });
        Assets.materials.star = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffea00, emissiveIntensity: 0.8, roughness: 0.2, metalness: 0.8 });

        const hx=0, hy=0; const heartShape = new THREE.Shape();
        heartShape.moveTo( hx, hy - 0.4 ); 
        heartShape.bezierCurveTo( hx, hy - 0.1, hx - 0.5, hy + 0.2, hx - 0.5, hy + 0.5 );
        heartShape.bezierCurveTo( hx - 0.5, hy + 0.7, hx - 0.3, hy + 0.9, hx, hy + 0.6 );
        heartShape.bezierCurveTo( hx + 0.3, hy + 0.9, hx + 0.5, hy + 0.7, hx + 0.5, hy + 0.5 );
        heartShape.bezierCurveTo( hx + 0.5, hy + 0.2, hx, hy - 0.1, hx, hy - 0.4 );
        Assets.geometries.heart = new THREE.ExtrudeGeometry( heartShape, { depth: 0.1, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.02, bevelThickness: 0.02 } );
        Assets.geometries.heart.center();
        Assets.geometries.heart.rotateX(Math.PI); Assets.geometries.heart.rotateX(-Math.PI / 2);
        Assets.materials.heart = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.6, roughness: 0.2, metalness: 0.5 });

        Assets.geometries.lightning = new THREE.IcosahedronGeometry(1, 0); 
        Assets.materials.lightning = new THREE.MeshStandardMaterial({ 
            color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2.0, roughness: 0.1, metalness: 0.5, wireframe: false
        });
        
        // ‚òÖW„Çπ„Ç≠„É´„Ç∑„Éº„É´„Éâ (ËªΩÈáèÂåñ: BasicMaterial + È†ÇÁÇπÂâäÊ∏õ)
        Assets.geometries.shield = new THREE.SphereGeometry(2.5, 24, 24);
        Assets.materials.shield = new THREE.MeshBasicMaterial({
            color: 0x00aaff, transparent: true, opacity: 0.3, side: THREE.DoubleSide
        });
    }

    function createTexture(type) {
        const size = 512; const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d');
        if (type === 'grass') {
            ctx.fillStyle = '#2a5a2a'; ctx.fillRect(0,0,size,size);
            for(let i=0;i<5000;i++){ ctx.fillStyle = Math.random()>0.5?'#3a6a3a':'#1a4a1a'; ctx.fillRect(Math.random()*size,Math.random()*size, 3, 3); }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
    }
    const TEXTURES = { grass: createTexture('grass') };

    class GameItem {
        constructor() {
            this.mesh = new THREE.Group();
            this.active = true;
            const range = CONFIG.mapLimit - 10;
            const x = (Math.random() - 0.5) * 2 * range;
            const z = (Math.random() - 0.5) * 2 * range;
            this.mesh.position.set(x, 2.5, z);
            this.baseY = 2.5; this.floatOffset = Math.random() * 100;
            scene.add(this.mesh);
        }
        update(dt, time) { }
        remove() { scene.remove(this.mesh); this.active = false; }
    }

    class SpeedItem extends GameItem {
        constructor() {
            super(); this.type = 'speed';
            const starMesh = new THREE.Mesh(Assets.geometries.star, Assets.materials.star);
            starMesh.scale.set(1.5, 1.5, 1.5);
            this.rotateGroup = new THREE.Group(); this.rotateGroup.add(starMesh);
            this.mesh.add(this.rotateGroup);
            const light = new THREE.PointLight(0xffd700, 1.5, 8); this.mesh.add(light);
        }
        update(dt, time) {
            this.rotateGroup.rotation.y += dt * 2.0;
            this.mesh.position.y = this.baseY + Math.sin(time * 3 + this.floatOffset) * 0.5;
        }
    }

    class HeartItem extends GameItem {
        constructor() {
            super(); this.type = 'heart';
            const heartMesh = new THREE.Mesh(Assets.geometries.heart, Assets.materials.heart);
            heartMesh.scale.set(1.5, 1.5, 1.5);
            this.rotateGroup = new THREE.Group(); this.rotateGroup.add(heartMesh);
            this.mesh.add(this.rotateGroup);
            const light = new THREE.PointLight(0xff0000, 1.5, 8); this.mesh.add(light);
        }
        update(dt, time) {
            this.rotateGroup.rotation.y += dt * 1.5;
            this.mesh.position.y = this.baseY + Math.sin(time * 2 + this.floatOffset) * 0.5;
        }
    }

    class LightningShot {
        constructor(pos, dir) {
            this.mesh = new THREE.Mesh(Assets.geometries.lightning, Assets.materials.lightning);
            this.mesh.scale.set(4.0, 4.0, 4.0);
            this.mesh.position.copy(pos); this.mesh.position.y = 2.5;
            this.velocity = dir.clone().normalize().multiplyScalar(60);
            this.life = 3.0;
            scene.add(this.mesh);
        }
        update(dt) {
            this.mesh.position.addScaledVector(this.velocity, dt);
            this.mesh.rotation.x += dt * 10; this.mesh.rotation.y += dt * 10;
            this.life -= dt;
            return this.life > 0;
        }
    }

    class StickmanModel {
        constructor() {
            this.mesh = new THREE.Group();
            this.animTime = 0; this.isMoving = false;
            this.mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.1 });
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), this.mat);
            head.position.y = 3.2; head.castShadow = true; this.mesh.add(head);
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.2, 4, 8), this.mat);
            body.position.y = 2.0; body.castShadow = true; this.mesh.add(body);
            
            const createLimb = (px, py, pz, geom, yOff) => {
                const joint = new THREE.Group(); joint.position.set(px, py, pz);
                const mesh = new THREE.Mesh(geom, this.mat); mesh.position.y = yOff; mesh.castShadow = true;
                joint.add(mesh); return joint;
            };
            const armGeo = new THREE.CapsuleGeometry(0.2, 1.2, 4, 8);
            const legGeo = new THREE.CapsuleGeometry(0.25, 1.4, 4, 8);
            this.armL = createLimb(-0.7, 2.8, 0, armGeo, -0.6); this.armR = createLimb(0.7, 2.8, 0, armGeo, -0.6);
            this.legL = createLimb(-0.3, 1.4, 0, legGeo, -0.7); this.legR = createLimb(0.3, 1.4, 0, legGeo, -0.7);
            this.mesh.add(this.armL); this.mesh.add(this.armR); this.mesh.add(this.legL); this.mesh.add(this.legR);

            // ‚òÖW„Çπ„Ç≠„É´„Ç∑„Éº„É´„Éâ
            this.wShield = new THREE.Mesh(Assets.geometries.shield, Assets.materials.shield);
            this.wShield.position.y = 2.0;
            this.wShield.visible = false;
            this.wShield.castShadow = false; // ÂΩ±„Å™„ÅóÔºàËªΩÈáèÂåñÔºâ
            this.wShield.receiveShadow = false;
            this.mesh.add(this.wShield);
        }
        
        setColor(hasItemShield) {
            if (hasItemShield) { this.mat.color.setHex(0xff0000); this.mat.emissive.setHex(0x550000); } 
            else { this.mat.color.setHex(0xffffff); this.mat.emissive.setHex(0x000000); }
        }

        setWShieldVisible(visible) {
            this.wShield.visible = visible;
        }

        update(dt) {
            if (!gameActive) this.isMoving = false;
            const speedScale = currentPlayerSpeed / CONFIG.basePlayerSpeed;
            this.animTime += dt * (this.isMoving ? 18 * speedScale : 0);
            
            if (this.isMoving) {
                const currentRot = this.mesh.quaternion.clone();
                const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position).normalize();
                if (dir.lengthSq() > 0.001) {
                    const targetAngle = Math.atan2(dir.x, dir.z);
                    const targetRot = new THREE.Quaternion();
                    targetRot.setFromAxisAngle(new THREE.Vector3(0,1,0), targetAngle);
                    this.mesh.quaternion.slerp(targetRot, 10.0 * dt);
                }
            }

            if (this.isMoving) {
                const as = 1.0; const ls = 1.2;
                this.armL.rotation.x = Math.sin(this.animTime) * as; this.armR.rotation.x = Math.sin(this.animTime + Math.PI) * as;
                this.legL.rotation.x = Math.sin(this.animTime + Math.PI) * ls; this.legR.rotation.x = Math.sin(this.animTime) * ls;
                this.mesh.position.y = Math.abs(Math.sin(this.animTime * 2)) * 0.15; 
                this.mesh.children[1].rotation.x = 0.2;
            } else {
                this.armL.rotation.x = 0; this.armR.rotation.x = 0;
                this.legL.rotation.x = 0; this.legR.rotation.x = 0;
                this.mesh.position.y = 0; this.mesh.children[1].rotation.x = 0;
            }
            
            if (this.wShield.visible) {
                this.wShield.scale.setScalar(1.0 + Math.sin(clock.elapsedTime * 10) * 0.05);
            }
        }
    }

    function createMap() {
        const group = new THREE.Group();
        const groundTex = createTexture('grass'); groundTex.repeat.set(40, 40);
        const groundMat = new THREE.MeshStandardMaterial({ map: groundTex, roughness: 0.8 });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.mapVisualSize, CONFIG.mapVisualSize), groundMat);
        ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; group.add(ground);
        return group;
    }

    class SkillBall {
        constructor(speedMultiplier, type = 'normal') {
            this.type = type;
            if (this.type === 'black') {
                this.radius = CONFIG.ballRadius * 3.0;
                this.mesh = new THREE.Mesh(Assets.geometries.ball, Assets.materials.blackBall);
                this.speedBase = CONFIG.baseBallSpeedMin * 0.8;
            } else {
                this.radius = CONFIG.ballRadius;
                this.mesh = new THREE.Mesh(Assets.geometries.ball, Assets.materials.ball);
                this.speedBase = CONFIG.baseBallSpeedMin + Math.random() * (CONFIG.baseBallSpeedMax - CONFIG.baseBallSpeedMin);
            }
            this.mesh.scale.set(this.radius, this.radius, this.radius);
            this.targetY = this.radius + 1.0; this.mesh.position.y = this.targetY; this.mesh.castShadow = true;
            
            const angle = Math.random() * Math.PI * 2; const dist = CONFIG.spawnDistance;
            const sx = Math.cos(angle) * dist; const sz = Math.sin(angle) * dist;
            this.mesh.position.set(sx, this.targetY, sz);
            
            const dir = new THREE.Vector3().subVectors(player.mesh.position, this.mesh.position).normalize();
            const lead = 0.5 + Math.min(0.5, survivalTime * 0.01); 
            const future = player.mesh.position.clone().add(dir.multiplyScalar(currentPlayerSpeed * lead));
            const finalDir = new THREE.Vector3().subVectors(future, this.mesh.position).normalize();
            
            this.speed = this.speedBase * speedMultiplier;
            this.velocity = finalDir.multiplyScalar(this.speed);
            this.rotAxis = new THREE.Vector3().crossVectors(finalDir, new THREE.Vector3(0,1,0)).normalize();
            
            scene.add(this.mesh);
        }
        update(dt) {
            this.mesh.position.addScaledVector(this.velocity, dt);
            this.mesh.rotateOnWorldAxis(this.rotAxis, this.speed * dt * 0.2);
            this.mesh.position.y = this.targetY;
            return this.mesh.position.length() < CONFIG.spawnDistance + 50;
        }
        checkHit(playerPos) {
            const distSq = this.mesh.position.distanceToSquared(playerPos);
            return distSq < (this.radius + 0.8) ** 2;
        }
    }

    function init() {
        try {
            const loader = document.getElementById('loading'); if (loader) loader.style.display = 'none';
            soundManager.init();
            
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x223344); 
            scene.fog = new THREE.Fog(0x223344, 80, 250);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            const amLight = new THREE.AmbientLight(0xffffff, 1.0); scene.add(amLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); dirLight.position.set(-50, 100, -50);
            dirLight.castShadow = true; 
            dirLight.shadow.mapSize.set(1024, 1024); 
            dirLight.shadow.camera.left = -CONFIG.mapLimit; dirLight.shadow.camera.right = CONFIG.mapLimit;
            dirLight.shadow.camera.top = CONFIG.mapLimit; dirLight.shadow.camera.bottom = -CONFIG.mapLimit;
            scene.add(dirLight);

            initAssets();

            mapGroup = createMap(); scene.add(mapGroup);
            player = new StickmanModel(); scene.add(player.mesh);
            const indGeo = new THREE.RingGeometry(1.0, 1.5, 32);
            const indMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0, side: THREE.DoubleSide });
            moveIndicator = new THREE.Mesh(indGeo, indMat);
            moveIndicator.rotation.x = -Math.PI/2; moveIndicator.position.y = 0.5; scene.add(moveIndicator);
            
            clock = new THREE.Clock(); raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            window.addEventListener('resize', onResize); window.addEventListener('contextmenu', onRightClick);
            window.addEventListener('keydown', onKeyDown);
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('retry-btn').addEventListener('click', retryGame);
            document.getElementById('menu-btn').addEventListener('click', goToMenu);
            document.getElementById('mute-btn').addEventListener('click', toggleMute);
            
            const slider = document.getElementById('volume-slider');
            slider.addEventListener('input', (e) => {
                soundManager.setVolume(e.target.value / 100);
            });

            document.addEventListener('click', () => {
                if (!gameActive && !soundManager.isMuted) {
                    soundManager.switchBGM('menu');
                }
            }, { once: true });

            gameActive = false; animate();
        } catch(e) { showError("Init failed: " + e.message); }
    }

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        resetGameState(); gameActive = true; clock.start();
        soundManager.play('start'); 
        soundManager.switchBGM('bgm');
    }
    function retryGame() {
        document.getElementById('result-overlay').style.display = 'none';
        resetGameState(); gameActive = true; clock.start();
        soundManager.play('start'); 
        soundManager.switchBGM('bgm');
    }
    function goToMenu() {
        document.getElementById('result-overlay').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
        resetGameState(); gameActive = false; 
        soundManager.switchBGM('menu');
    }
    function toggleMute() {
        const isMuted = soundManager.toggleMute();
        const btn = document.getElementById('mute-btn');
        if (isMuted) { btn.innerText = "üîá Èü≥OFF"; btn.classList.add('muted'); } 
        else { btn.innerText = "üîä Èü≥ON"; btn.classList.remove('muted'); }
    }

    function resetGameState() {
        survivalTime = 0; spawnCooldown = 0;
        speedItemCooldown = CONFIG.speedItemInterval; heartItemCooldown = CONFIG.heartItemInterval;
        skills.forEach(s => disposeObject(s.mesh)); skills = [];
        items.forEach(i => i.remove()); items = [];
        lightnings.forEach(l => disposeObject(l.mesh)); lightnings = []; 
        player.mesh.position.set(0, 0, 0); targetPos.set(0, 0, 0);
        player.isMoving = false; moveIndicator.material.opacity = 0;
        player.mesh.rotation.set(0,0,0);
        currentPlayerSpeed = CONFIG.basePlayerSpeed;
        
        itemShieldActive = false;
        wSkillShieldActive = false;
        wSkillTimer = 0;
        player.setColor(false);
        player.setWShieldVisible(false);
        updateSpeedUI();
        updateShieldUI();

        qUnlocked = false; wUnlocked = false;
        qCoolTimer = 0; wCoolTimer = 0;
        updateSkillUI();
    }

    function updateSpeedUI() {
        const percent = Math.round((currentPlayerSpeed / CONFIG.basePlayerSpeed) * 100);
        document.getElementById('speed-display').innerText = `„Çπ„Éî„Éº„Éâ: ${percent}%`;
    }
    
    function updateShieldUI() {
        const el = document.getElementById('shield-display');
        if (itemShieldActive) {
            el.style.display = 'block';
            el.innerText = "‚ô• „Éê„É™„Ç¢Áô∫Âãï‰∏≠ ‚ô•";
        } else {
            el.style.display = 'none';
        }
    }

    function updateSkillUI() {
        // Q Skill
        const qEl = document.getElementById('skill-q');
        if (!qUnlocked) {
            const rem = Math.max(0, CONFIG.skillUnlockTimeQ - survivalTime).toFixed(0);
            qEl.className = 'skill-box cooldown'; qEl.innerText = `Q: ${rem}ÁßíÂæå`;
        } else if (qCoolTimer > 0) {
            qEl.className = 'skill-box cooldown'; qEl.innerText = `Q: ${qCoolTimer.toFixed(1)}`;
        } else {
            qEl.className = 'skill-box ready'; qEl.innerText = "Q: READY";
        }

        // W Skill
        const wEl = document.getElementById('skill-w');
        if (!wUnlocked) {
            const rem = Math.max(0, CONFIG.skillUnlockTimeW - survivalTime).toFixed(0);
            wEl.className = 'skill-box cooldown'; wEl.innerText = `W: ${rem}ÁßíÂæå`;
        } else if (wSkillShieldActive) {
            wEl.className = 'skill-box active'; wEl.innerText = `W: ACTIVE`;
        } else if (wCoolTimer > 0) {
            wEl.className = 'skill-box cooldown'; wEl.innerText = `W: ${wCoolTimer.toFixed(1)}`;
        } else {
            wEl.className = 'skill-box ready'; wEl.innerText = "W: READY";
        }
    }

    function updateCamera() {
        if(!player) return;
        const targetX = player.mesh.position.x; const targetZ = player.mesh.position.z + CONFIG.cameraOffsetZ;
        camera.position.x += (targetX - camera.position.x) * 0.1;
        camera.position.z += (targetZ - camera.position.z) * 0.1;
        camera.position.y = CONFIG.cameraHeight;
        camera.lookAt(camera.position.x, 0, camera.position.z - CONFIG.cameraOffsetZ);
    }

    function onKeyDown(e) {
        if (!gameActive) return;
        if (e.key === 's' || e.key === 'S') {
            targetPos.copy(player.mesh.position); player.isMoving = false; moveIndicator.material.opacity = 0;
        }
        if ((e.key === 'q' || e.key === 'Q') && qUnlocked && qCoolTimer <= 0) {
            fireLightning();
            qCoolTimer = CONFIG.qCooldown;
        }
        if ((e.key === 'w' || e.key === 'W') && wUnlocked && wCoolTimer <= 0 && !wSkillShieldActive) {
            activateWSkill();
        }
    }

    function fireLightning() {
        const dir = new THREE.Vector3();
        if (player.isMoving) {
            dir.subVectors(targetPos, player.mesh.position);
        } else {
            const v = new THREE.Vector3(0,0,1);
            v.applyQuaternion(player.mesh.quaternion);
            dir.copy(v);
        }
        if (dir.lengthSq() === 0) dir.set(0, 0, -1); 

        lightnings.push(new LightningShot(player.mesh.position, dir));
        soundManager.play('skill'); 
    }

    function activateWSkill() {
        wSkillShieldActive = true;
        wSkillTimer = CONFIG.wDuration;
        player.setWShieldVisible(true);
        soundManager.play('shield');
    }

    function onRightClick(e) {
        e.preventDefault(); if (!gameActive) return;
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); const intersect = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, intersect);
        if (intersect) {
            targetPos.copy(intersect); moveIndicator.position.copy(targetPos);
            moveIndicator.position.y = 0.5; moveIndicator.material.opacity = 1; moveIndicator.scale.set(1,1,1);
        }
    }

    function manageSpawns(dt) {
        spawnCooldown -= dt;
        if (spawnCooldown <= 0) {
            const speedMult = 1.0 + Math.min(0.5, survivalTime * 0.01);
            const baseInterval = Math.max(0.1, 0.8 - (survivalTime * 0.015));
            let count = 1;
            if (survivalTime > 30 && Math.random() < 0.3) count = 2;
            if (survivalTime > 60 && Math.random() < 0.5) count = 3;
            for(let i=0; i<count; i++) {
                let type = 'normal';
                if (survivalTime > 100 && Math.random() < 0.15) type = 'black'; 
                skills.push(new SkillBall(speedMult, type));
            }
            spawnCooldown = baseInterval;
        }
        speedItemCooldown -= dt;
        if (speedItemCooldown <= 0) { items.push(new SpeedItem()); speedItemCooldown = CONFIG.speedItemInterval; }
        heartItemCooldown -= dt;
        if (heartItemCooldown <= 0) { items.push(new HeartItem()); heartItemCooldown = CONFIG.heartItemInterval; }
    }

    const _pPos = new THREE.Vector3();
    const _dir = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);
        let delta = clock.getDelta(); if (!delta || delta > 0.1 || isNaN(delta)) delta = 0.016; 
        const time = clock.getElapsedTime();
        
        if (gameActive) {
            survivalTime += delta; manageSpawns(delta);
            
            if (!qUnlocked && survivalTime >= CONFIG.skillUnlockTimeQ) { qUnlocked = true; soundManager.play('shield'); }
            if (!wUnlocked && survivalTime >= CONFIG.skillUnlockTimeW) { wUnlocked = true; soundManager.play('shield'); }
            
            if (qCoolTimer > 0) qCoolTimer -= delta;
            if (wCoolTimer > 0) wCoolTimer -= delta;
            
            if (wSkillShieldActive) {
                wSkillTimer -= delta;
                if (wSkillTimer <= 0) {
                    wSkillShieldActive = false;
                    player.setWShieldVisible(false);
                    wCoolTimer = CONFIG.wCooldown;
                }
            }
            updateSkillUI();

            const dist = player.mesh.position.distanceTo(targetPos);
            if (dist > 0.5) {
                player.isMoving = true;
                _dir.subVectors(targetPos, player.mesh.position).normalize();
                const moveDist = currentPlayerSpeed * delta;
                if (moveDist >= dist) player.mesh.position.copy(targetPos);
                else player.mesh.position.add(_dir.multiplyScalar(moveDist));
            } else { player.isMoving = false; }
            
            if (moveIndicator.material.opacity > 0) { moveIndicator.material.opacity -= delta * 3; moveIndicator.scale.multiplyScalar(0.9); }

            for (let i = lightnings.length - 1; i >= 0; i--) {
                const bolt = lightnings[i];
                const alive = bolt.update(delta);
                if (!alive) {
                    disposeObject(bolt.mesh); lightnings.splice(i, 1); continue;
                }
                for (let j = skills.length - 1; j >= 0; j--) {
                    const enemy = skills[j];
                    const distSq = bolt.mesh.position.distanceToSquared(enemy.mesh.position);
                    if (distSq < (2.0 + enemy.radius) ** 2) { 
                        if (enemy.type === 'black') {
                            // ÈªíÁéâ„ÅØÁÑ°Êïµ
                        } else {
                            disposeObject(enemy.mesh); skills.splice(j, 1);
                        }
                    }
                }
            }

            for (let i = skills.length - 1; i >= 0; i--) {
                const s = skills[i]; const alive = s.update(delta);
                _pPos.copy(player.mesh.position); _pPos.y = s.mesh.position.y; 
                if (s.checkHit(_pPos)) {
                    if (wSkillShieldActive) {
                        disposeObject(s.mesh); skills.splice(i, 1);
                        soundManager.play('break');
                    } else if (itemShieldActive) {
                        itemShieldActive = false; player.setColor(false); updateShieldUI();
                        disposeObject(s.mesh); skills.splice(i, 1);
                        soundManager.play('break');
                    } else { 
                        endGame(); return; 
                    }
                } else if (!alive) { disposeObject(s.mesh); skills.splice(i, 1); }
            }
            
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i]; item.update(delta, time);
                _pPos.copy(player.mesh.position);
                const distSq = (_pPos.x - item.mesh.position.x)**2 + (_pPos.z - item.mesh.position.z)**2;
                if (distSq < 6.25) {
                    if (item.type === 'speed') {
                        currentPlayerSpeed += CONFIG.speedBoostAmount; updateSpeedUI();
                        item.remove(); items.splice(i, 1); soundManager.play('item');
                    } else if (item.type === 'heart') {
                        if (!itemShieldActive) { 
                            itemShieldActive = true; player.setColor(true); updateShieldUI();
                            item.remove(); items.splice(i, 1); soundManager.play('shield');
                        }
                    }
                }
            }
            document.getElementById('timer').innerText = survivalTime.toFixed(2);
        }
        if (player) player.update(delta);
        updateCamera(); renderer.render(scene, camera);
    }

    function endGame() {
        gameActive = false; 
        soundManager.stopAllBGM(); 
        soundManager.play('defeat');
        document.getElementById('final-score').innerText = "Ë®òÈå≤: " + survivalTime.toFixed(2) + "Áßí";
        document.getElementById('result-overlay').style.display = 'flex';
    }
    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.onload = init;
</script>
</body>
</html>